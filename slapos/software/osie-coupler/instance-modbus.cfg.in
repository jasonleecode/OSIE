#############################
#
# Deploy  OSIE coupler instance
#
#############################
[buildout]
parts =
  directory
  publish-connection-parameter
  coupler-modbus
  coupler-modbus-promise

# Define egg directories to be the one from Software Release
# (/opt/slapgrid/...)
# Always the same.
eggs-directory = {{ buildout['eggs-directory'] }}
develop-eggs-directory = {{ buildout['develop-eggs-directory'] }}
offline = true
extends = {{ template_monitor }}

[instance-parameter]
# Fetch arbitrary parameters defined by the user in SlapOS Master for his instance.
# We use the slapconfiguration recipe with a few parameters (partition id,
# computer id, certificate, etc).
# It will then authenticate to SlapOS Master and fetch the instance parameters.
# The parameters are accessible from ${instance-parameter:configuration.name-of-parameter}
# Always the same. Just copy/paste.
# See docstring of slapos.cookbook:slapconfiguration for more information.
recipe = slapos.cookbook:slapconfiguration
computer = ${slap-connection:computer-id}
partition = ${slap-connection:partition-id}
url = ${slap-connection:server-url}
key = ${slap-connection:key-file}
cert = ${slap-connection:cert-file}

configuration.coupler_block_device =
configuration.coupler_i2c_slave_list =

# Define default parameter(s) that will be used later, in case user didn't
# specify it.
# All possible parameters should have a default.
# In our use case, we are expecting from the user to specify one (optional) parameter: "name". We put the default value here if he doesn't specify it, so that it doesn't crash.
configuration.interface = 0.0.0.0
configuration.modbus_port = 1502
# If our use case requires that the user can specify a mail address so that his instance can mail to him (for example), we can do:
# configuration.mail-address =
# If the user doesn't specify it, it won't break and the recipe can handle it (i.e don't send any mail for example).

# Create all needed directories, depending on your needs
[directory]
recipe = slapos.cookbook:mkdirectory
home = ${buildout:directory}
etc = ${:home}/etc
var = ${:home}/var
# Executables put here will be started but not monitored (for startup scripts)
script = ${:etc}/run/
# Executables put here will be started and monitored (for daemons)
service = ${:etc}/service
# Path of the log directory used by our service (see [helloweb])
log = ${:var}/log

[coupler-modbus]
# the service will log here
logfile = ${directory:log}/coupler-modbus.log

# Actual script that starts the service:
# This recipe will try to "exec" the command-line after separating parameters.
recipe = slapos.cookbook:wrapper
command-line =
    {{ buildout['bin-directory'] }}/pythonwitheggs {{ buildout['parts-directory'] }}/osie/eggs/osie_coupler/osie_modbus.py -p ${instance-parameter:configuration.modbus_port}
# Put this shell script in the "etc/service" directory. Each executable of this
# repository will be started and monitored by supervisord. If a service
# exits/crashes, it will trigger a "bang" and cause a re-run of the instance.
wrapper-path = ${directory:service}/coupler-modbus

# promise, that checks that helloweb service is alive
[coupler-modbus-promise]
<= monitor-promise-base
module = check_port_listening
name = coupler.py
config-hostname= ${instance-parameter:configuration.interface}
config-port    = ${instance-parameter:configuration.modbus_port}

# Publish all the parameters needed for the user to connect to the instance.
# It can be anything: URL(s), password(s), or arbitrary parameters.
# Here we'll just echo back the entered name as instance parameter
[publish-connection-parameter]
recipe = slapos.cookbook:publish
modbus_port = ${instance-parameter:configuration.modbus_port}
interface = ${instance-parameter:configuration.interface}
